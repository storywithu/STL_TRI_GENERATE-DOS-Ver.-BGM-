#include <cstdio>
#include <clocale>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <locale>
#include <vector>
#include <Windows.h>
#include <string>
#include <stdio.h>
#include <stdlib.h>

using namespace std;
using std::vector;


int main()
{
	filesystem::path p("./SPL_ASCII.STL");
	string filename = "SPL_ASCII.STL";

	cout << "Does " << p << " exist? [" << boolalpha
		<< filesystem::exists(p) << "]" << endl;
	cout << "Is " << p << " file? [" << filesystem::is_regular_file(p) << "]" << endl;
	
	ifstream ifs(filename.c_str(), ios::binary);
	if (!ifs)
	{
		ifs.close();
		cout << "Read stl file error. It might be binary stl file. Check it again~" << endl;
		return false;
	}

	string s;
	string word = "endfacet";
	string vt_ = "vertex";
	
	int count1 = 0;
	int index = 0;
	int count2 = 0;

	//point p1;
	//point p2;
	//point p3;
	//...
	//count
	//p1.new_pt(10, 10, 10);
	//return 0;

	/*class point
		{
		private:
			float x, y, z;
			float cx, cy, cz;

		public:
			void new_pt(cx, cy, cz)
			{
				x = cx;
				y = cy;
				z = cz;
			}
		}
	*/

	if (ifs.is_open())
	{
		ifs >> s;
		using namespace std;

		while (!ifs.eof())
		{
			getline(ifs, s);

			if (s.find("vertex") != -1)
			{
				count1++;
				//string.substr(5, 3);
				//string substr (size_t pos, size_t len) const;
			}
					
			if (s.find("endfacet") != -1)
			{
				++count2;
			}
			
		}

		cout << "The number of triangle is" << count2 << endl;
		cout << "The number of vertex is" << count1 << endl;

	}
	else
	{
		cout << "파일을 찾을 수 없습니다!" << endl;
	}


	float** fv_xyz = new float*[count1];

	for (int i = 0; i < count1; i++)            // 세로 크기만큼 반복
	{
		fv_xyz[i] = new float[3];   // (int의 크기 * col)만큼 동적 메모리 할당. 배열의 가로
	}
	for (int i = 0; i < count1; i++)    // 세로 크기만큼 반복
	{
		for (int j = 0; j < 3; j++)    // 가로 크기만큼 반복
		{
			fv_xyz[i][j] = (7.688343e+01 2.300000e+01 5.102530e-01);             // 2차원 배열의 각 요소에 i + j 값을 할당
		}
	}
	cout << "fv_xyz[10][2]:" << fv_xyz[10][2] << endl;

	for (int i = 0; i < count1; i++)              //메모리 해제 , 행마다 해제해주고
	{
		delete[] fv_xyz[i];
	}
	delete[] fv_xyz;            //마지막으로 행도 해제



	ofstream fin_tri("output.txt", ios_base::out);


	return 0;

	ifs.close();
}






/*
bool Mesh::readSTL_ASCII(std::string fileName)
{
	ifstream ifs(fileName.c_str(), ios::binary);
	if (!ifs)
	{
		ifs.close();
		cout << "read stl error" << endl;
		return false;
	}

	vtx.clear();
	tris.clear();

	int intSize = sizeof(int);
	int floatSize = sizeof(float);

	float tn0, tn1, tn2;
	float v0, v1, v2;
	float cx = 0.0, cy = 0.0, cz = 0.0;

	string name1, name2;
	ifs >> name1 >> name2;
	//cout << "name: " << name1 << " " << name2 <<  endl;
	int t = 0;

	while (!ifs.eof())
	{
		string temp2;
		ifs >> temp2;
		if (temp2 == "facet")
		{
			string temp_normal;
			ifs >> temp_normal;
			ifs >> tn0 >> tn1 >> tn2;
			//cout << "normal: " << tn0 << " " << tn1 << " " << tn2 << endl;

			Normal faceN;
			faceN.x = tn0;
			faceN.y = tn1;
			faceN.z = tn2;
			faceNrm.push_back(faceN);

			ifs.ignore(11);
			string temp;
			ifs >> temp;
			//cout << "SSS:" << temp << endl;
			while (temp == "vertex")
			{
				//cout << "=========================" << endl;
				ifs >> v0 >> v1 >> v2;
				//cout << "vertex: " << v0 << " " << v1 << " " << v2 << endl;
				vtx.push_back(Vertex(v0, v1, v2));
				cx += v0;
				cy += v1;
				cz += v2;

				ifs >> temp;
				//cout << "temp: " << temp << endl;
			}
			//cout << "end1: " << temp << endl;
			ifs >> temp;
			//cout << "end2: " << temp << endl;
		}

		if (temp2 != "endsolid")
		{
			Tri tri;
			tri.v1 = t * 3 + 0;
			tri.v2 = t * 3 + 1;
			tri.v3 = t * 3 + 2;
			tris.push_back(tri);
			t = t + 1;
		}
	}
	ifs.close();

	// Calculate the center position
	center.x = cx / (tris.size() * 3);
	center.y = cy / (tris.size() * 3);
	center.z = cz / (tris.size() * 3);

	//Calculate the radius
	radius = 0;
	for (int i = 0; i < vtx.size(); i++)
	{
		vtx[i] = vtx[i] - center;
		float lens;
		lens = sqrt((vtx[i]).dot(vtx[i]));
		if (lens > radius)
		{
			radius = lens;
		}
	}
	// Zero the center position of the model
	center.x = 0;
	center.y = 0;
	center.z = 0;
	return true;
}
*/